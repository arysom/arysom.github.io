{"data":{"markdownRemark":{"html":"<p><em>Ten wpis dotyczył będzie laravela, ale użyte w nim stwierdzenia mają swoje odniesienie do całego środowiska php. Laravel posłuży tutaj jako przykład zastosowania a sposób w jaki proponuję ustawić środowisko developerskie jest jedną z propozycji.</em></p>\n<p>Jeśli chodzi o uruchamianie projektów php w celu lokalnej developerki dawniej korzystaliśmy z programów typu xampp, uczyliśmy się obsługi serwera apache na linuxie, zamartwialiśmy się o zawartość pliku etc/hosts gdzieś w systemie. Na szczęście te czasy odchodzą w niepamięć.</p>\n<h2>Docker</h2>\n<p>Mamy Dockera. Z czym to się je, co to jest? Najprościej mówiąc jest to zamknięte, wirtualne środowisko, jak się potocznie mówi: kontener. Nie ważne jak skonfigurowany jest Twój system, jaką masz wersję PHP, Node, Ruby - kontener ma swoją niezależną rzeczywistość. <a href=\"https://docs.docker.com/get-started/\">Dokumentacja dockera</a> jest bogata w szczegóły, kontenery łączy się w grupy, trzeba zadbać o \"data persistence\", bo przy każdym zatrzymaniu kontenera, wraca on do swojej poprzedniej postaci. Prawda, że na razie brzmi to skomplikowanie?</p>\n<h2>Docker Compose</h2>\n<p>Na szczęście twórcy dockera wymyślili narzędzie <a href=\"https://docs.docker.com/compose/install/#install-compose\">docker-compose</a>, jest ono dołączone do dockera i cała jego zaleta polega na tym, że konfigurację wielu kontenerów trzyma się w jednym pliku. Wystarczy <code>docker-compose up</code> i jeśli posiadamy dobrze skonfigurowany plik <strong>docker-compose.yml</strong> - system wystartuje i pozostaje nam już tylko \"wstukanie\" adresu w przeglądarkę, lub wykonanie komendy za pomocą <code>docker-composer exec [nazwa_kontenera] [moja_komenda]</code>.</p>\n<h2>Docker Compose Laravel</h2>\n<p>Laravel wraz z pojawianiem się nowych wersji dostosowywał się do nowszych wersji PHP i wraz z pojawieniem się PHP 7 użytkownik nie używający wirtualnych środowisk był zmuszony podnosić wersję php w swoim systemie. A co jeśli miał inne projekty zależne np. od paczek działających tylko w starym php? Po to właśnie są kontenery.</p>\n<p>Osoba mało obeznana z tematyką dockera, a tym bardziej docker-compose w przypadku istniejących już projektów laravela ma możliwość skorzystania z gotowego rozwiązania: <a href=\"https://github.com/jguyomard/docker-laravel\">https://github.com/jguyomard/docker-laravel</a>.</p>\n<h3>Jak dodać do projektu?</h3>\n<p>Nie ważne czy dopiero wystartowaliśmy czy projekt już istnieje. Zwyczajnie kopiujemy plik docker-compose.yml do głównego katalogu instalacji laravela, a następnie odpalamy w terminalu komendę: <code>docker-compose up</code>.</p>\n<p>Docker ściąga potrzebne kontenery, które są opisane w powyższym pliku i nie pozostaje nam nic innego,jak wejść w przeglądarce na adres <code>0.0.0.0:8080</code>. Dlaczego właśnie taki? Warto poświęcić chwilę czasu na zrozumienie zawartości pliku docker-compose.yml . Oto on w całości:</p>\n<pre><code>version: '2'\nservices:\n\n  php:\n    image: jguyomard/laravel-php:7.2\n    volumes:\n      - ./:/var/www/\n      - $HOME/.composer/:$HOME/.composer/\n    environment:\n      - \"DB_HOST=mysql\"\n      - \"DB_DATABASE=homestead\"\n      - \"DB_USERNAME=homestead\"\n      - \"DB_PASSWORD=homestead\"\n      - \"REDIS_HOST=redis\"\n      - \"REDIS_PORT=6379\"\n\n  nginx:\n    image: jguyomard/laravel-nginx:1.13\n    volumes_from:\n      - php\n    ports:\n      - 8080:80\n\n  mysql:\n    image: mysql:5.7\n    volumes:\n      - mysqldata:/var/lib/mysql\n    environment:\n      - \"MYSQL_ROOT_PASSWORD=secret\"\n      - \"MYSQL_DATABASE=homestead\"\n      - \"MYSQL_USER=homestead\"\n      - \"MYSQL_PASSWORD=homestead\"\n#    ports:\n#        - \"3306:3306\"\n\n#  pgsql:\n#    image: postgres:9.6-alpine\n#    volumes:\n#      - pgsqldata:/var/lib/postgresql/data\n#    environment:\n#      - \"POSTGRES_DB=homestead\"\n#      - \"POSTGRES_USER=homestead\"\n#      - \"POSTGRES_PASSWORD=homestead\"\n#    ports:\n#        - \"5432:5432\"\n\n  redis:\n    image: redis:4.0-alpine\n    command: redis-server --appendonly yes\n#    ports:\n#        - \"6379:6379\"\n\n#  elastic:\n#    image: elasticsearch:5.5-alpine\n#    ports:\n#        - \"9200:9200\"\n\nvolumes:\n  mysqldata:\n  pgsqldata:\n</code></pre>\n<p>Plik przy odrobinie wiedzy z zakresu dockera sam się tłumaczy. Ale po kolei: </p>\n<ul>\n<li><code>#</code> oznacza naturalnie komentarz, autor zostawia nam opcjonalnie parę możliwości, a to skorzystanie z redisa lub z wyszukiwania elastic search</li>\n<li>pliki yml czyta się kaskadowo, więc już na początku widać, jak nazywają się nasze kontenery: php, nginx, mysql . Będzie to miało znaczenie przy uruchamianiu komendy. Np. wiemy, że artisan jest w kontenerze php, więc dlatego wpisujemy <code>docker-compose exec php php artisan ...</code>. Pierwsze php to nazwa kontenera, drugie oznacza, że korzystamy z binarki php, która jest dostępna w kontenerze. Jest to PHP w wersji 7.2, a więc najnowszej i od razu dzięki temu możemy bez zbędnych ceregieli uruchomić nasz projekt z użyciem najnowszych technologii,</li>\n<li>image, to nazwa obrazu z serwisu docker hub. Można tworzyć własne i autor specjalnie przygotował php-laravel oraz nginx, które działają od razu. Można się pokusić np o zmianę cyferek przy obrazie mysql, np na 5.3 i zobaczyć, co się stanie z naszym projektem, czy przy takiej wersji nadal będziemy się cieszyć poprawnym działaniem</li>\n<li>volumes - to właśnie kawałek odpowiedzialny za zachowanie danych, które mogą zniknąć przy zatrzymaniu kontenerów, po lewej stronie dwukropka jest część odpowiedzialna za położenie wewnątrz kontenera, a po prawej - bezpieczne położenie w naszym systemie. Na samym dole są wymienione \"volumes\", które są dostępne w kontenerach,</li>\n<li>volumes_from : w tym przypadku widać, że kontener nginx używa volumes z kontenera php, są ze sobą połączone,</li>\n<li>environment - zmienne użyte wewnątrz kontenera, co ważne, mają nadrzędne znaczenie w stosunku do konfiguracji zawartej np w .env laravela. Warto, żeby np. nazwy baz danych były specyficzne dla projektu, gdyż jeśli będą zawsze nazywały się <code>homestead</code> - istnieje ryzyko nadpisania przy zapisie w \"volumie\" na naszym dysku,</li>\n<li>ports - tutaj podobnie jak w volumes, po lewej jest część opisująca nasze środowisko (0.0.0.0:8080 - pamiętamy), a po prawej wewnątrz kontenera. Jakie to ma znaczenie? Kontenery łączą się miedzy sobą właśnie portami, które opisujemy w skryptach, ale co, gdy np chcemy podejrzeć zawartość bazy mysql bez wchodzenia do środka kontenera (tak tak, możemy zrobić <code>docker-compose exec php ls</code> i zobaczyć, co siedzi w środku). Korzystamy z portu po lewej stronie \"wystawionego\" do połączeń spoza kontenera, a więc w naszym komputerze.</li>\n</ul>\n<p>I to byłoby na tyle. Jeszcze jedno ostrzeżenie, że w przypadku tej konfiguracji docker-compose upload plików jest ograniczony do 2M, ale dla chcącego nic trudnego, wystarczy zrobić własne custom.ini ze zmiennymi PHP odpowiedzialnymi za wielkość uploadu i POST'u i dodać jedną linijkę w docker-compose.yml, w konterze php, żeby kontener zaczął korzystać z naszej konfiguracji. \"Just google it...\"</p>","fields":{"slug":"/docker-compose-laravel/","date":"2018-07-19"},"frontmatter":{"title":"Laravel docker prosto"}}},"pageContext":{}}